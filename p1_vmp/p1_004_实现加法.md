



<!-- 总结 -->
这是两头一起走的工程代码 一面写编译器  一面写解释器   缺啥补啥
编译器  只做编译  就是不管往栈里赛东西  也不对 这里应该这么想  这里最终的产出是一个列表包含指令和数据  只是在这个过程中思考了栈 本身并不和栈进行运行时交互 说白了就是最终一个字符串 只和这个大字符串交互
    最终落地表现就是 
    推进去了 ***指令 
    push ******数据

    在推的过程中  定义了指令表  和常量表
    这里指令表有一个很好的设计 只有js可以这么做  牛逼的设计  双向绑定了   
    ```
    const INST={} {
        INST[INST['PUSH']=101] = 'PUSH'
    }
    ```
解释器 就需要逐个解释执行了  这个就是缺啥补啥  也需要跟栈交互,这里本身就开始了和大字符串进行逐个运行 它还要维护一个栈

以上两个方面都会出现自定义指令集的情况  栈都发挥了中心作用     

指令到底是啥 现在开来就是ast递归到最后实在无法递归了就开始出现指令了 比如push  add 加减乘除 两次出栈......



<!-- 抽象图 -->











<!-- 我的疑问 不符合我直觉的迷思 -->
1 为什么单独抽离出来常量表  而不是直接吧他们写到指令集中?

